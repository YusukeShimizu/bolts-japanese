# ルートブラインディング

## 目次

* [提案](#proposal)
  * [はじめに](#introduction)
  * [概要](#overview)
  * [表記](#notations)
  * [要件](#requirements)
  * [暗号化されたデータ](#encrypted-data)
  * [ブラインドされたルートの作成](#creating-a-blinded-route)
  * [ブラインドされたルートへの送信](#sending-to-a-blinded-route)
  * [ブラインドされたルートからの受信](#receiving-from-a-blinded-route)
  * [ブラインドされた支払い](#blinded-payments)
* [攻撃](#attacks)
  * [支払いプロービングによるチャネルのアンブラインド](#unblinding-channels-with-payment-probing)
  * [再起動後のノードのアンブラインド](#unblinding-nodes-after-restart)
* [ヒントとコツ](#tips-and-tricks)
  * [受取人が手数料を支払う](#recipient-pays-fees)
  * [ダミーホップ](#dummy-hops)
  * [ウォレットと未発表のチャネル](#wallets-and-unannounced-channels)
  * [ブラインドされたルートの選択](#blinded-route-selection)
  * [ブラインドされたトランポリンルート](#blinded-trampoline-route)
* [FAQ](#faq)
  * [なぜランデブーを使わないのか](#why-not-use-rendezvous)
  * [なぜHORNETを使わないのか](#why-not-use-hornet)

## 提案

### はじめに

ルートブラインディングは、オニオンパスの終端で任意の数のホップをブラインドすることで受取人の匿名性を提供する軽量な技術です。ランデブールーティングよりも柔軟で、ルート内のノードの公開鍵をランダムな公開鍵に置き換え、送信者が各ホップのオニオンに入れるデータを選択できるようにします。ブラインドされたルートは、場合によっては再利用可能です（例：オニオンメッセージ）。

ランデブーと比較した場合の欠点は、送信者がさまざまな変数を変更してプロービングする余地があるため、このスキームはプロービング攻撃に対して明示的に防御する必要があり、ある種の攻撃に対してはプライバシーが低下する可能性があることです。

ルートブラインディングが有用なユースケースには以下が含まれます：

* オニオンメッセージの送信者と受取人の匿名性
* Bolt 12オファーの受取人の匿名性
* 支払いを受け取る際の受取人の匿名性
* 未発表のチャネルを明かさずに請求書で使用する
* 支払いを特定の中継者セットを通過させ、それらが支払いを目撃できるようにする

### 概要

大まかに言うと、ルートブラインディングは受取人が _導入ポイント_ を選び、その導入ポイントから自分自身へのルートを選択することで機能します。受取人はそのルートに沿った各ノードとチャネルを ECDH でブラインドします。受取人はブラインドされたルートの詳細といくつかの暗号材料を送信者に送ります（Bolt 11 インボイスまたは Bolt 12 オファーを介して）。これにより、送信者はブラインドされたルート内のノードが次のノードを段階的にアンブラインドできるようにするための十分な情報を持ったオニオンを構築できます。

このスキームは、ブラインドされたルート内のすべてのノードと送信者がこの機能のサポートを有効にすることを要求します。意味のあるプライバシー保証を提供するためには、ネットワークの十分な割合がこれをサポートする必要があります。

### 表記

* ノード `N(i)` の `node_id` は次のように定義されます：`N(i) = k(i) * G` （`k(i)` はノードの秘密鍵）。
* ブラインドされた `node_id` は次のように定義されます：`B(i) = b(i) * G` （`b(i)` はブラインディングファクター）。
* Sphinx の一時的な公開鍵は次のように定義されます：`E(i) = e(i) * G`。

### 要件

ノード `N(r)` は、オニオンを受け取るために使用されるべきブラインドされたルート `N(0) -> N(1) -> ... -> N(r)` を提供したいと考えています。

* ブラインドされたルート内の中間ノードは、直前または直後のノードを除いて、他の中間ノードの `node_id` または `scid` を知ってはなりません。
* ブラインドされたルート内の中間ノードは、受取人 `N(r)` までの距離を知ってはなりません。
* 送信者は、導入ポイント `N(0)` の後のブラインドされた中間ホップの実際の `node_id` と `scid` を知ってはなりません。
* `N(r)` が自分自身への複数のブラインドされたルートを作成する場合、送信者はこれらのルートが同じ受取人に通じていることを判別できてはなりません（もちろん、同じ `payment_hash` を使用するなど、プロトコルの上位層によってこの情報が漏洩しない限り）。

### 暗号化データ

ルートブラインディングは、オニオンの `tlv_payload` に新しい TLV フィールドを導入します：`encrypted_data`。

このフィールドは、ルートの構築者から送信者によって変更できないデータを運ぶために使用されます。中間ノードがルート内の次のノードを特定するための十分なデータ（通常は `node_id` または `scid`）を含む必要があり、将来的には追加のデータで拡張される可能性があります。ChaCha20-Poly1305 を AEAD スキームとして使用します。

1. type: 10 (`encrypted_data`)
2. data:
    * [`...*byte`:`encrypted_data`]

復号されると、この暗号化されたペイロードの内容は TLV ストリームです。

### ブラインドルートの作成

`N(r)` は、ブラインドルートを作成するために次のステップを実行します：

```text
Initialization:

  e(0) <- {0;1}^256
  E(0) = e(0) * G

Blinding:

  For i = 0 to r:
    ss(i) = H(e(i) * N(i)) = H(k(i) * E(i))         // shared secret known only by N(r) and N(i)
    B(i) = HMAC256("blinded_node_id", ss(i)) * N(i) // Blinded node_id for N(i), private key known only by N(i)
    rho(i) = HMAC256("rho", ss(i))                  // Key used to encrypt payload for N(i) by N(r)
    e(i+1) = H(E(i) || ss(i)) * e(i)                // Ephemeral private key, only known by N(r)
    E(i+1) = H(E(i) || ss(i)) * E(i)                // NB: N(i) must not learn e(i)
```

これは Sphinx と全く同じ構造ですが、各ホップで共有秘密を使用して `N(i)` のブラインドされた `node_id` を導出します。このプライベートキーは `N(i)` のみが知ることになります。

受信者は次に、`rho(i)` キーを使用して ChaCha20-Poly1305 でアプリケーション固有のデータを暗号化することにより、`encrypted_data(i)` を作成します。

ブラインドルートを使用するために、送信者は次のデータを必要とします：

* イントロダクションポイント `N(0)` の実際の `node_id` （ルートの開始点を特定するため）
* ブラインドされた `node_id` のリスト：`[B(1),...,B(r)]`
* 各ノードの暗号化データ：`[encrypted_data(0),...,encrypted_data(r)]`
* 最初のブラインディング一時鍵：`E(0)`

### ブラインドルートへの送信

送信者はイントロダクションポイント `N(0)` へのルートを見つけ、それをブラインドルートで拡張します。その後、その全ルートのためのオニオンを作成し、`E(0)` と `encrypted_data(0)` を `N(0)` のオニオンペイロードに含めます。`encrypted_data(i)` を `B(i)` のオニオンペイロードに含めます。

`N(0)` がオニオンを受信して復号すると、ペイロード内に `E(0)` を見つけ、次の計算が可能になります：

```text
  ss(0) = H(k(0) * E(0))
  rho(0) = HMAC256("rho", ss(0))
  E(1) = H(E(0) || ss(0)) * E(0)
```

`rho(0)` を使用して `encrypted_data(0)` を復号し、`B(1)` が実際には `N(1)` であることを発見します。それはオニオンを `N(1)` に転送し、`E(1)` をライトニングメッセージの TLV フィールドに含めます（例えば、`update_add_htlc` メッセージの拡張フィールドに）。

その後のすべての中間ノード `N(i)` は次のステップを実行します：

```text
  E(i) <- extracted from the lightning message's fields
  ss(i) = H(k(i) * E(i))
  b(i) = HMAC256("blinded_node_id", ss(i)) * k(i)
  Use b(i) instead of k(i) to decrypt the incoming onion using sphinx
  rho(i) = HMAC256("rho", ss(i))
  Use rho(i) to decrypt the `encrypted_data` inside the onion and discover the next node
  E(i+1) = H(E(i) || ss(i)) * E(i)
  Forward the onion to the next node and include E(i+1) in a TLV field in the message
```

### ブラインドルートからの受信

`N(r)` がオニオンメッセージと `E(r)` を受信すると、中間ノードと同じアンラッピングを行います。違いは、オニオンが最終オニオンであることです。

`N(r)` はまた、ブラインドルートが作成されたコンテキストで使用されたことを検証し、それが自分たちが作成したルートであることを確認しなければなりません。誰でも他の誰かに対して有効なブラインドルートを作成できることに注意することが重要です。例えば、アリスは `Bob -> Carol -> Dave` というブラインドルートを作成することができます。ほとんどの場合、デイブは他の誰かが作成したルートを通じて来るメッセージを無視したいと考えます。

この検証ステップの詳細は、ルートブラインディングを使用する実際のアプリケーションに依存します。例えば、支払いのためにブラインドされたルートを使用する場合、受信者はそのルートが正しい `payment_hash` と共に使用されたことを確認する必要があります。これを行うために、`payment_preimage` を `encrypted_data` ペイロードに保存し、支払いを受け取る際にそれを検証します。悪意のある送信者は事前にプレイメージを知らないため、満足のいくルートを作成することはできません。

この検証ステップがないと、受信者は悪意のあるプロービングにさらされ、攻撃者がルートを匿名化解除する可能性があります。

### Blinded payments

このセクションでは、支払いのためにルートブラインディングをどのように使用できるかについての詳細を提供します。

悪意のあるプロービング（[Attacks](#attacks) セクションで詳述）から保護するために、ルート内で使用される支払いリレーのパラメータ（例：手数料）を選択し、それらを各ブラインドノードの `encrypted_data` ペイロードにエンコードするのは受信者です。送信者はブラインドされた中間ノードのオニオンペイロードに `amt_to_forward` と `outgoing_cltv_value` フィールドを設定しません。これらのノードは代わりに `encrypted_data` に記載された指示に従います。

各中間ノードの `encrypted_data` には以下のフィールドが含まれます：

* `short_channel_id`: 支払いをルーティングするために使用すべきアウトゴーイングチャネル
* `fee_base_msat`: 支払いをリレーする前に適用すべき基本手数料
* `fee_proportional_millionths`: 支払いをリレーする前に適用すべき比例手数料
* `cltv_expiry_delta`: 支払いをリレーする前に適用すべき cltv 期限デルタ
* `max_cltv_expiry`: この支払いに許可される最大期限
* `htlc_minimum_msat`: 受け入れるべき最小 htlc 金額
* `allowed_features`: 送信者が使用することを許可されている支払いリレーに関連する機能

受信者は、近隣のチャネルを見て、それらのチャネルの十分な数に対して機能する値を選択することで、十分な匿名性セットを提供する値を使用する必要があります。そうしないと、例えば選択された手数料が他の候補のほとんどよりも低い場合、悪意のある送信者がブラインドされたルート内のチャネルを特定するのが容易になります。

受取人は `payment_preimage`（または支払いのための他のプライベートな一意識別子）を `encrypted_data` ペイロードの `path_id` フィールドに含めます。これにより、受取人はそのルートが特定の支払いのためだけに使用され、自分によって生成されたものであることを確認できます。

ブラインドルート内のノードが `encrypted_data` に提供されたパラメータを使用しない支払いを受け取った場合、その支払いを拒否し、解析不能なエラーオニオンで応答しなければなりません。これにより、支払者はどのノードが失敗したのか、またその理由を知ることができなくなります（そうでなければ、支払者がルート内のノードを調査するために使用できるデータを提供することになります）。

また、`max_cltv_expiry` フィールドを提供していることにも注意してください。これにより、ブラインドルートが一定時間後に期限切れとなり、将来の調査試行を制限します。

すべてのノードが `var_onion_option` をサポートしていると仮定する場合、現時点では `allowed_features` フィールドを含める必要はありません。支払いリレーに影響を与え、調査ベクトルとして使用される可能性のある他の機能はないからです。しかし、将来の更新でそのような機能（例：PTLC サポート）が追加される場合、`allowed_features` フィールドは空であってはなりません。

これらの要件を明確にするために、例を見てみましょう。

アリスは次のブラインドルートで請求書を作成します：`キャロル -> ボブ -> アリス`。
そのルートに沿ったチャネルは次の設定を持っています：

* `キャロル -> ボブ`
  * `fee_base_msat`: 10
  * `fee_proportional_millionths`: 250
  * `cltv_expiry_delta`: 144
  * `htlc_minimum_msat`: 1
* `ボブ -> アリス`
  * `fee_base_msat`: 50
  * `fee_proportional_millionths`: 100
  * `cltv_expiry_delta`: 48
  * `htlc_minimum_msat`: 1000

アリスは、上記のチャネルの要件を満たし、ノードがリレーのパラメータを更新する場合に備えて安全マージンを追加した、次のパラメータをブラインドルートに選択します：

* `fee_base_msat`: 100
* `fee_proportional_millionths`: 500
* `htlc_minimum_msat`: 1000
* `cltv_expiry_delta`: 144

アリスは簡単のために両方のチャネルに同じ値を使用します。アリスは今、ルートの終わりから順に（反復的に）整数演算を使用して `ceil(a/b)` を `(a+b-1)/b` として計算し、完全なルートの集計値を計算できます（値を切り上げないと、送信者が意図したよりもわずかに少ない金額を受け取る可能性があります）。


* `route_fee_base_msat(n+1) = (fee_base_msat(n+1) * 1000000 + route_fee_base_msat(n) * (1000000 + fee_proportional_millionths(n+1)) + 1000000 - 1) / 1000000`
* `route_fee_proportional_millionths(n+1) = ((route_fee_proportional_millionths(n) + fee_proportional_millionths(n+1)) * 1000000 + route_fee_proportional_millionths(n) * fee_proportional_millionths(n+1) + 1000000 - 1) / 1000000`

アリスは `min_final_cltv_expiry_delta` として 12 ブロックを使用したいと考えており、これをルートの
合計 `cltv_expiry_delta` に追加します。これにより、次の値が得られます：

* `route_fee_base_msat`: 201
* `route_fee_proportional_millionths`: 1001
* `route_cltv_expiry_delta`: 300

現在のブロック高が 1000 であると仮定します。アリスは次の 200 ブロックでルートを使用したいと考えており、支払者に伝える `max_cltv_expiry` は 1200 になります。
ただし、`min_final_cltv_expiry_delta` として 12 も必要であるため、自分自身への暗号化されたペイロードでは、
`max_cltv_expiry = 1212` と設定し、その後の各ホップに `cltv_expiry_delta` を追加します。アリスは次の情報を送信者に送信します（おそらく請求書を介して）：

* ブラインドルート: `[N(carol), B(bob), B(alice)]`
* 最初のブラインディング一時鍵: `E(carol)`
* 集約されたルートリレーのパラメータと制約：
  * `fee_base_msat`: 201
  * `fee_proportional_millionths`: 1001
  * `htlc_minimum_msat`: 1000
  * `cltv_expiry_delta`: 300
  * `max_cltv_expiry`: 1200（10 分ブロックを想定して請求書の有効期限を介して伝達される可能性があります）
  * `allowed_features`: 空
* ブラインドノード用の暗号化データ：
  * `encrypted_payload(alice)`:
    * `path_id`: `payment_preimage`
    * `max_cltv_expiry`: 1212
  * `encrypted_payload(bob)`:
    * `outgoing_channel_id`: `scid_bob_alice`
    * `fee_base_msat`: 100
    * `fee_proportional_millionths`: 500
    * `htlc_minimum_msat`: 1000
    * `max_cltv_expiry`: 1356
  * `encrypted_payload(carol)`:
    * `outgoing_channel_id`: `scid_carol_bob`
    * `fee_base_msat`: 100
    * `fee_proportional_millionths`: 500
    * `htlc_minimum_msat`: 1000
    * `max_cltv_expiry`: 1500

導入ポイント (キャロル) は、送信者がこの導入ポイントを見つけてルートを見つける必要があるため、ブラインドされたものではなく実際の `node_id` を使用します。送信者は、キャロルのためにオニオン `hop_payload` に最初のブラインディング一時鍵 `E(carol)` を送信します。これにより、キャロルはブラインディング共有秘密を計算し、正しく転送できます。このブラインディング一時鍵をオニオンに入れるのは、ブラインドされたルートの前に追加された中間ノードがルートブラインディングをサポートしていない可能性があり、それを中継する方法がわからないためです。

エリンはこのブラインドされたルートに 100,000 msat を送信したいと考えています。
彼女はデイブ経由でキャロルに到達できます：`Erin -> Dave -> Carol`。ここで、デイブとキャロルの間のチャネルは次のリレー・パラメータを使用します：

* `fee_base_msat`: 10
* `fee_proportional_millionths`: 100
* `cltv_expiry_delta`: 24

エリンは集約されたルートリレー・パラメータを使用して、キャロルに送信すべき金額を計算します：

* `amount = 100000 + 201 + (1001 * 100000 + 1000000 - 1) / 1000000 = 100302 msat`

エリンは 1100 の最終期限を選びます。これはアリスの `max_cltv_expiry` よりも低いです。この値は、[ルーティングの推奨事項](../07-routing-gossip.md#recommendations-for-routing) に記載されているように、現在のブロック高さにランダムな cltv オフセットを追加することで選択できます。

エリンはキャロルに送信すべき期限を計算します：

* `expiry = 1100 + 300 = 1400`

ブラインドされたルート内のノードが htlc を受け取ると、オニオンには `amt_to_forward` や `outgoing_cltv_value` が含まれません。それらは、`encrypted_data` に含まれるフィールド (`fee_base_msat`、`fee_proportional_millionths`、`cltv_expiry_delta`) に基づいて計算する必要があります。

例えば、キャロルがボブにリレーする htlc の値を計算する方法は次のとおりです：

* `amount = ((100302 - fee_base_msat) * 1000000 + 1000000 + fee_proportional_millionths - 1) / (1000000 + fee_proportional_millionths) = 100152 msat`
* `expiry = 1400 - cltv_expiry_delta = 1256`

そして、ボブがアリスにリレーする htlc の値を計算する方法は次のとおりです：

* `amount = ((100152 - fee_base_msat) * 1000000 + 1000000 + fee_proportional_millionths - 1) / (1000000 + fee_proportional_millionths) = 100002 msat`
* `expiry = 1256 - cltv_expiry_delta = 1112`

送金額の丸め誤差が累積すると、受取人は予想よりもわずかに多くの金額を受け取ることになります。送信者は、受取人が受け取った金額が送信者が意図した金額よりも（わずかに）多いことを確認できるように、`amt_to_forward` をオニオンペイロードに含めます（これは、中間ノードがより少ない金額を中継しようとするのを防ぎます）。

交換されるメッセージには、以下の値が含まれます：

```text
    Erin                                          Dave                                                   Carol                                                   Bob                                         Alice
      |             update_add_htlc                |              update_add_htlc                          |             update_add_htlc                          |             update_add_htlc                |
      |     +--------------------------------+     |      +------------------------------------------+     |     +------------------------------------------+     |     +--------------------------------+     |
      |     |  amount: 100322 msat           |     |      |  amount: 100302 msat                     |     |     |  amount: 100152 msat                     |     |     |  amount: 100002 msat           |     |
      |     |  expiry: 1424                  |     |      |  expiry: 1400                            |     |     |  expiry: 1256                            |     |     |  expiry: 1112                  |     |
      |     |  onion_routing_packet:         |     |      |  onion_routing_packet:                   |     |     |  onion_routing_packet:                   |     |     |  onion_routing_packet:         |     |
      |     | +----------------------------+ |     |      | +--------------------------------------+ |     |     | +--------------------------------------+ |     |     | +----------------------------+ |     |
      | --> | | amount_fwd: 100302 msat    | | --> | -->  | | blinding_eph_key: E(carol)           | | --> | --> | | encrypted_data:                      | | --> | --> | | amount_fwd: 100000 msat    | | --> |
      |     | | outgoing_expiry: 1400      | |     |      | | encrypted_data:                      | |     |     | | +----------------------------------+ | |     |     | | outgoing_expiry: 1112      | |     |
      |     | | scid: scid_dave_to_carol   | |     |      | | +----------------------------------+ | |     |     | | | scid: scid_bob_to_alice          | | |     |     | | encrypted_data:            | |     |
      |     | +----------------------------+ |     |      | | | scid: scid_carol_to_bob          | | |     |     | | | fee_base_msat: 100               | | |     |     | | +-----------------------+  | |     |
      |     | | blinding_eph_key: E(carol) | |     |      | | | fee_base_msat: 100               | | |     |     | | | fee_proportional_millionths: 500 | | |     |     | | | path_id: preimage     |  | |     |
      |     | | encrypted_data(carol)      | |     |      | | | fee_proportional_millionths: 500 | | |     |     | | | htlc_minimum_msat: 1000          | | |     |     | | | max_cltv_expiry: 1200 |  | |     |
      |     | +----------------------------+ |     |      | | | htlc_minimum_msat: 1000          | | |     |     | | | cltv_expiry_delta: 144           | | |     |     | | +-----------------------+  | |     |
      |     | | encrypted_data(bob)        | |     |      | | | cltv_expiry_delta: 144           | | |     |     | | | max_cltv_expiry: 1356            | | |     |     | +----------------------------+ |     |
      |     | +----------------------------+ |     |      | | | max_cltv_expiry: 1500            | | |     |     | | +----------------------------------+ | |     |     |  tlv_extension                 |     |
      |     | | amount_fwd: 100000 msat    | |     |      | | +----------------------------------+ | |     |     | +--------------------------------------+ |     |     | +----------------------------+ |     |
      |     | | outgoing_expiry: 1112      | |     |      | +--------------------------------------+ |     |     | | amount_fwd: 100000 msat              | |     |     | | blinding_eph_key: E(alice) | |     |
      |     | | encrypted_data(alice)      | |     |      | | encrypted_data(bob)                  | |     |     | | outgoing_expiry: 1112                | |     |     | +----------------------------+ |     |
      |     | +----------------------------+ |     |      | +--------------------------------------+ |     |     | | encrypted_data(alice)                | |     |     +--------------------------------+     |
      |     +--------------------------------+     |      | | amount_fwd: 100000 msat              | |     |     | +--------------------------------------+ |     |                                            |
      |                                            |      | | outgoing_expiry: 1112                | |     |     |  tlv_extension                           |     |                                            |
      |                                            |      | | encrypted_data(alice)                | |     |     | +--------------------------------------+ |     |                                            |
      |                                            |      | +--------------------------------------+ |     |     | | blinding_eph_key: E(bob)             | |     |                                            |
      |                                            |      +------------------------------------------+     |     | +--------------------------------------+ |     |                                            |
      |                                            |                                                       |     +------------------------------------------+     |                                            |
      |                                            |                                                       |                                                      |                                            |
```

すべてのオニオンペイロードは明確にするために各 `update_add_htlc` で説明されていますが、最初のものだけがメッセージを受け取る中間ノードによって復号化されることができます（標準の Bolt 4 オニオン暗号化）。

## 攻撃

### 支払いプロービングによるチャネルの非ブラインド化

受取人は、攻撃者がルート内に隠されたノードを推測しないように、支払いにルートブラインディングを使用する際に注意が必要です。なぜそうなるのかを理解するために、攻撃を見てみましょう。

ルーティンググラフが次のようになっていると仮定します：

```text
               +-------+      +-------+
               |   X   |      |   X   |
               +-------+      +-------+
                   |              |
                   |              |
+-------+      +-------+      +-------+      +-------+
|   X   |------| Carol |------|  Bob  |------| Alice |
+-------+      +-------+      +-------+      +-------+
                   |              |
                   |              |
               +-------+      +-------+
               |   X   |      |   X   |
               +-------+      +-------+
```

アリスはブラインドされたルート `キャロル -> ボブ -> アリス` を作成します。アリスはブラインドされたルート内で使用される手数料設定を選択しました。彼女が `fee_base_msat = 10` と `fee_proportional_millionths = 100` を選んだと仮定します。

攻撃者は、受取人がキャロルから最大で 2 ホップ以内にいることを知っています。支払いを行う代わりに、攻撃者はキャロルの周囲 2 ホップの範囲内のすべてのチャネルに対する新しい `channel_update` を監視します。ある時点で、攻撃者は `ボブ -> アリス` チャネルの `channel_update` を見て、`fee_proportional_millionths = 150` に設定されていることを確認します。これはアリスがブラインドされたルートに選んだものを超えています。攻撃者は支払いを試みます。

ボブが支払いを受け取ると、手数料は現在の設定を下回っているため、拒否するはずです。攻撃者は失敗を受け取り、アリスが最終受取人である可能性が非常に高いと推測できます。

攻撃者が受取人から頻繁に請求書を要求できる場合（例：Bolt 12 オファーから）、支払いを試みることなくこれを検出できます。単に受取人から定期的に請求書を要求し、受取人がブラインドされたルートの手数料や cltv を引き上げたときに、それを最近受け取った `channel_update` と一致させることができます。

同様に、支払い中継の動作に適用されるフィーチャービットは、ブラインドルート内のノードをフィンガープリントするために使用される可能性があります。このため、`allowed_features` は `encrypted_data` 内にコミットされます。

ネットワーク全体のノードが異なる `htlc_minimum_msat` の値を使用する場合、それもノードをフィンガープリントするために使用される可能性があります。そのため、これも `encrypted_data` 内にコミットされます。

この種の攻撃があるため、支払い中継の動作に影響を与えるすべてのパラメータ（手数料、cltv、フィーチャーなど）は受取人によって選択されます。受取人は、将来の値上げに対して保護するために、ルート内のノードが実際に使用している現在の値に十分なマージンを追加するべきです。これが、支払いに使用されるブラインドルートに `max_cltv_expiry` が受取人によって設定されている理由でもあります。ただし、攻撃者が頻繁に新しいブラインドルートを要求できる場合、この問題を完全に解決するわけではありません。

ブラインドルート内の利他的な中継ノードは、現在の設定よりも低い手数料で支払いを中継することを選択するかもしれませんが、これによりこのヒューリスティックが破られることになります。しかし、彼らの経済的インセンティブはそれを拒否することにあるため、受取人のプライバシーを保護するために彼らに頼ることはできません。

同様に、中継ノードには `encrypted_data` ペイロードで提供された手数料を正確に使用して支払いを受け入れることを義務付けています。そうでない場合、特定のチャネルの手数料を引き上げる `channel_update` を観察した際に、攻撃者はこれらの新しい手数料を支払い試行に使用しようとする可能性があります。もし支払いが通過すれば、ブラインドルートで使用されたチャネルについてさらに確信を持つことができます。中継ノードのインセンティブはあまり良くありません。なぜなら、受取人のプライバシーを保護するために適切な手数料を提供する支払いを拒否するよう求めているからです。

### 再起動後のノードのアンブラインド

前のセクションで説明した攻撃は、支払いのためにルートブラインディングを使用するシナリオにのみ適用されました。しかし、同じ技術のバリエーションは、メッセージを中継するためにルートブラインディングに依存する任意のシナリオに使用できます。

攻撃者が特定のノード `N` がブラインドルートの一部である可能性があると疑う場合、そのノードがオフラインになるのを待ち、ノードがオフラインの間にブラインドルートを使用しようとすることができます。もしブラインドルートが失敗した場合、そのノードが実際にブラインドルートの一部であった可能性が高いです。このサンプリングを定期的に繰り返すことで、攻撃者はアンブラインドの確信を高めることができます。

この問題に対処するために、受取人は高い稼働率を持つノードをブラインドルートに選び、定期的にそれらを更新するべきです。

## Tips and Tricks

### 受取人が手数料を支払う

受取人の匿名性を確保するために支払者がより多くの手数料を支払うのは不公平かもしれません。代わりに、受取人がブラインドホップの手数料を支払い、支払者が紹介ポイントに到達するための手数料を支払うべきです。

もし商人が `N` サトシで商品を販売している場合、ルートのブラインド部分の手数料 `f` を差し引いた `N-f` サトシの請求書を作成するべきです。

### ダミーホップ

送信者は受取人と `N(0)` の間の距離の上限を知っています。受取人が `N(0)` に近い場合、これは理想的ではないかもしれません。そのような場合、受取人は `N(j) = N(r)` を使用して、ブラインドルートの末尾に任意の数のダミーホップを追加することができます。送信者はそれらを通常のブラインドホップと区別することはできません。

NB:

* 受取人は、改ざんを検出するために各ダミーホップのオニオンペイロードを完全に検証する必要があります（これらのホップが使用され、切り捨てられていないことを確認しなければなりません）
* 受取人はすべての `encrypted_data` ペイロードが同じ長さになるようにパディングを使用する必要があります。そうでないと、支払者がどのホップが実際に受取人であるかを推測できるようになります

### ウォレットと未発表のチャネル

ルートブラインディングは、未発表のチャネルを介してノードに接続されているウォレットに特に有用です。このようなウォレットは、単一のブラインドホップを使用することで、送信者から `node_id` と `scid` を効果的に隠すことができます。もちろん、ブラインドノードには次のノードが最終受取人であることが明らかになりますが、常にオンラインで安定した IP を持たないウォレットは、接続するノードからその情報を隠すことはできません（ランデブーを使用しても）。

### ブラインドルートの選択

受取人がブラインドルートを作成する際に、良好なプライバシーを確保しつつ、良好な支払いの信頼性を維持するために使用できる戦略は多岐にわたります。以下にこれらの戦略のいくつかを紹介します。これらはあくまで例であり、実装はユーザのニーズに合った戦略を見つけるべきです。

受取人が公開ノードではなく、ピアの数が少ない場合は非常に簡単です。各ピアごとに 1 つのパスを含めることができます。例えば、モバイルウォレットのトポロジーは通常次のようになります。

```text
               +-------+      +-------+
    +----------| Carol |      |   X   |
    |          +-------+      +-------+
    |              |              |
    |              |              |
+-------+      +-------+      +-------+      +-------+
| Alice |------|  Bob  |------|   X   |------|   X   |
+-------+      +-------+      +-------+      +-------+
    |                             |
    |                             |
    |                         +-------+
    +-------------------------| Dave  |
                              +-------+
```

アリスは、各ピアごとに 1 つのブラインドパスとダミーホップを含むブラインドルートを提供できます。

* ボブ   -> Blinded(Alice) -> Blinded(Alice) -> Blinded(Alice)
* キャロル -> Blinded(Alice) -> Blinded(Alice) -> Blinded(Alice)
* デイブ  -> Blinded(Alice) -> Blinded(Alice) -> Blinded(Alice)

アリスは、ボブ、キャロル、デイブから最大 3 ホップ離れた任意のノードである可能性があるため、大きな匿名性セットの恩恵を受けながら、すべてのインバウンド流動性を利用できます。

受取人が公開ノードである場合、その戦略は異なります。多くのピアを持つ紹介ノードを使用して、良好な匿名性セットを取得する必要があります。アリスの近隣が次のようなトポロジーを持っていると仮定します。

```text
+-------+      +-------+
|   X   |      |   X   |
+-------+      +-------+
    |              |
    |              |
+-------+      +-------+      +-------+
|  N1   |------|  N2   |------|   X   |
+-------+      +-------+      +-------+
    |              |              |
    |              |              |
+-------+      +-------+      +-------+      +-------+
| Alice |------|  N3   |------|  N4   |------|   X   |
+-------+      +-------+      +-------+      +-------+
```

アリスは深さ 2 の BFS を実行して、N2 と N4 が大きな匿名性セットを提供する良い紹介ノードであることを確認できます。次に、以下のブラインドパスを提供できます。

* N2 -> Blinded(N1) -> Blinded(Alice) -> Blinded(Alice)
* N4 -> Blinded(N3) -> Blinded(Alice) -> Blinded(Alice)

アリスは、匿名性セット内のすべてのチャネルの支払い中継パラメータを分析し、それらの十分なサブセットに対して機能する手数料/cltv を選択するべきです。

アリスは重複しないパスを選択したことに注意してください。そうでない場合、パスの容量が予想される支払いよりもはるかに大きくない限り、これらのパスには彼女が受け取ることを期待する支払いを中継するのに十分な流動性がない可能性があります。

受取人が大きな支払いを受け取ることを期待している場合、流動性があまりにも多くのピアに分散されていると問題になる可能性があります。受取人は、十分な流動性が利用可能であることを確認するために、直接のピアである紹介ノードを使用することを余儀なくされるかもしれません（この場合、ブラインドパスにダミーホップを含めることが特に有用です）。

### ブラインドトランポリンルート

ルートブラインディングは、トランポリンと非常に簡単に組み合わせて使用することもできます。`encrypted_data` に `outgoing_channel_id` を提供する代わりに、単に `outgoing_node_id` を提供する必要があります。

各トランポリンノードは次のノードの `node_id` を復号し、次のトランポリンノードのために `E(i)` を計算できます。その `E(i)` は、ライトニングメッセージのフィールドを使用する代わりに外部オニオンペイロードで送信でき、さらにクリーンで、トランポリンノード間のノードがルートブラインディングを理解する必要がありません。

ブラインドされたトランポリンルートを使用することは、多くのピアを持ち、支払いの信頼性に影響を与える流動性の問題に直面するパブリックノードにとって良い解決策です。そのような受取人は、彼らに向かって多くのパスを見つけることができるトランポリンノードを選ぶことができます：

```text
               +-------+                     +-------+      
    +----------|   X   |--------+   +--------|   X   |----------+
    |          +-------+        |   |        +-------+          |
    |                           |   |                           |
    |                           |   |                           |
+-------+      +-------+      +-------+      +-------+      +-------+
|  T1   |------|   X   |------| Alice |------|   X   |------|  T2   |
+-------+      +-------+      +-------+      +-------+      +-------+
    |                           |   |                           |
    |                           |   |                           |
    |          +-------+        |   |        +-------+          |
    +----------|   X   |--------+   +--------|   X   |----------+
               +-------+                     +-------+      
```

アリスは次のブラインドされたトランポリンパスを提供できます：

* T1 -> Blinded(Alice)
* T2 -> Blinded(Alice)

T1 と T2 はアリスに向かって多くのパスを見つけることができ、いくつかのパスが失敗した場合には再試行し、潜在的な流動性の制約を回避します。

## FAQ

### なぜランデブーを使用しないのか

ランデブーはよりプライベートですが、柔軟性に欠けます：送信者は部分的なオニオンにデータを追加したり、それを再利用したりすることができません。支払いに使用する場合、金額は部分的なオニオン内で事前に固定されている必要があり、マルチパート支払いや一時的な流動性の問題と組み合わせるのが難しいです。

ルートブラインディングは、送信者がオニオンペイロードに入れるデータのほとんどを選択できるようにし、より柔軟にしますが、攻撃者に対するプロービングの表面を増やすという代償があります。

### なぜ HORNET を使用しないのか

HORNET は有用なスピードアップを提供する前に遅いセッションセットアップを必要とします。セッションごとに 1 つのメッセージを送信することを期待する場合（支払いやオニオンメッセージの場合）、HORNET は実際にはレイテンシ、帯域幅、プライバシーの点で Sphinx よりもパフォーマンスが劣ります。
